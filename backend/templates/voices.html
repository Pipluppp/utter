{% extends "base.html" %}

{% block title %}Voices - Utter{% endblock %}

{% block content %}
<h1 class="title-page">Your Voices</h1>

<div id="error-container" class="message hidden"></div>

<div class="voices-controls">
    <input type="text" id="voices-search" placeholder="Search voices..." />
    <select id="voices-source-filter">
        <option value="">All types</option>
        <option value="uploaded">Clones</option>
        <option value="designed">Designed</option>
    </select>
</div>

<div id="voices-container" class="voices-grid">
    <div class="loading-placeholder">Loading voices...</div>
</div>

<div class="voices-empty hidden" id="empty-state">
    <p id="empty-message">No voices yet.</p>
    <a href="/clone" class="btn" id="empty-cta">Clone Your First Voice</a>
</div>

<div class="voices-pagination hidden" id="pagination">
    <button id="prev-page" disabled>Previous</button>
    <span id="page-info">Page 1 of 1</span>
    <button id="next-page">Next</button>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const container = document.getElementById('voices-container');
        const emptyState = document.getElementById('empty-state');
        const emptyMessage = document.getElementById('empty-message');
        const emptyCta = document.getElementById('empty-cta');
        const errorContainer = document.getElementById('error-container');
        const searchInput = document.getElementById('voices-search');
        const sourceFilter = document.getElementById('voices-source-filter');
        const pagination = document.getElementById('pagination');
        const prevBtn = document.getElementById('prev-page');
        const nextBtn = document.getElementById('next-page');
        const pageInfo = document.getElementById('page-info');

        let currentPage = 1;
        const perPage = 20;
        let currentSearch = '';
        let currentSearchTokens = [];
        let currentSource = '';
        let debounceTimer = null;

        async function loadVoices() {
            showLoading();
            clearError();

            try {
                const params = new URLSearchParams();
                params.set('page', currentPage);
                params.set('per_page', perPage);
                if (currentSearch) params.set('search', currentSearch);
                if (currentSource) params.set('source', currentSource);

                const response = await fetch(`/api/voices?${params.toString()}`);
                if (!response.ok) {
                    throw new Error('Failed to load voices');
                }

                const data = await response.json();
                const voices = data.voices || [];
                currentSearchTokens = getSearchTokens(currentSearch);

                if (data.pagination && data.pagination.pages && currentPage > data.pagination.pages) {
                    currentPage = data.pagination.pages;
                    if (currentPage < 1) currentPage = 1;
                    await loadVoices();
                    return;
                }

                if (voices.length === 0) {
                    container.classList.add('hidden');
                    emptyState.classList.remove('hidden');
                    pagination.classList.add('hidden');
                    setEmptyStateMode();
                    return;
                }

                emptyState.classList.add('hidden');
                container.classList.remove('hidden');
                container.innerHTML = voices.map(renderVoiceCard).join('');
                updatePagination(data.pagination);

            } catch (error) {
                showError(error.message || 'Failed to load voices');
            }
        }

        function renderVoiceCard(voice) {
            const rawName = voice.name || 'Untitled Voice';
            const nameForAttr = escapeHtml(rawName);
            const nameHtml = highlightMatches(rawName, currentSearchTokens);
            const createdAt = formatDate(voice.created_at);
            const language = voice.language ? escapeHtml(voice.language) : '';

            const transcript = voice.reference_transcript ? String(voice.reference_transcript) : '';
            const transcriptText = transcript
                ? highlightMatches(truncateText(transcript, 180), currentSearchTokens)
                : '<span class="voice-snippet-empty">No transcript</span>';

            const description = voice.description ? String(voice.description) : '';
            const descriptionHtml = description
                ? `
                    <div class="voice-snippet-block">
                        <div class="voice-snippet-label">Description</div>
                        <div class="voice-snippet-text">${highlightMatches(truncateText(description, 180), currentSearchTokens)}</div>
                    </div>
                `
                : '';

            const tag = getVoiceTag(voice.source);

            return `
            <div class="voice-card" data-id="${voice.id}">
                <div class="voice-card-header">
                    <div class="voice-card-title">
                        <h3 class="voice-card-name">${nameHtml}</h3>
                        <div class="voice-card-meta">
                            <span class="voice-tag ${tag.className}">${tag.label}</span>
                            ${language ? `<span class="voice-card-language">${language}</span>` : ''}
                        </div>
                    </div>
                    <span class="voice-card-date">${createdAt}</span>
                </div>
                <div class="voice-card-details">
                    <div class="voice-snippet-block">
                        <div class="voice-snippet-label">Reference</div>
                        <div class="voice-snippet-text">${transcriptText}</div>
                    </div>
                    ${descriptionHtml}
                </div>
                <div class="voice-card-actions">
                    <button class="btn btn-secondary preview-btn" data-id="${voice.id}">
                        Preview
                    </button>
                    <a href="/generate?voice=${voice.id}" class="btn">
                        Generate
                    </a>
                    <button class="btn btn-secondary delete-btn" data-id="${voice.id}" data-name="${nameForAttr}">
                        Delete
                    </button>
                </div>
                <div id="waveform-${voice.id}" class="waveform-container hidden"></div>
            </div>
        `;
        }

        function setEmptyStateMode() {
            const hasFilters = Boolean(currentSearch || currentSource);
            if (hasFilters) {
                emptyMessage.textContent = 'No results.';
                emptyCta.textContent = 'Clear Filters';
                emptyCta.href = '/voices';
            } else {
                emptyMessage.textContent = 'No voices yet.';
                emptyCta.textContent = 'Clone Your First Voice';
                emptyCta.href = '/clone';
            }
        }

        function updatePagination(paginationData) {
            if (!paginationData || paginationData.total === 0) {
                pagination.classList.add('hidden');
                return;
            }

            const totalPages = paginationData.pages || 1;
            const page = paginationData.page || 1;

            pagination.classList.remove('hidden');
            pageInfo.textContent = `Page ${page} of ${totalPages}`;
            prevBtn.disabled = page <= 1;
            nextBtn.disabled = page >= totalPages;
        }

        function showLoading() {
            container.innerHTML = '<div class="loading-placeholder">Loading voices...</div>';
        }

        function showError(message) {
            errorContainer.textContent = message;
            errorContainer.classList.remove('hidden', 'success');
            errorContainer.classList.add('error');
        }

        function clearError() {
            errorContainer.classList.add('hidden');
            errorContainer.classList.remove('error', 'success');
        }

    function formatDate(isoString) {
        if (!isoString) return '';
        const date = new Date(isoString);
        return date.toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric',
            year: 'numeric'
        });
    }

    function truncateText(text, maxLen) {
        if (!text) return '';
        return text.length > maxLen ? text.substring(0, maxLen) + '...' : text;
    }

    function escapeHtml(text) {
        return String(text)
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    }

    function getSearchTokens(search) {
        if (!search) return [];
        return search
            .trim()
            .split(/\s+/)
            .map(t => t.trim())
            .filter(Boolean);
    }

    function highlightMatches(text, tokens) {
        const raw = text === null || text === undefined ? '' : String(text);
        if (!tokens || tokens.length === 0) return escapeHtml(raw);

        const lower = raw.toLowerCase();
        const spans = [];

        for (const token of tokens) {
            const t = String(token).toLowerCase();
            if (!t) continue;

            let start = 0;
            while (start < lower.length) {
                const idx = lower.indexOf(t, start);
                if (idx === -1) break;
                spans.push({ start: idx, end: idx + t.length });
                start = idx + t.length;
            }
        }

        if (spans.length === 0) return escapeHtml(raw);

        spans.sort((a, b) => (a.start - b.start) || (b.end - a.end));

        const merged = [];
        for (const span of spans) {
            const prev = merged[merged.length - 1];
            if (!prev || span.start > prev.end) {
                merged.push({ start: span.start, end: span.end });
                continue;
            }
            prev.end = Math.max(prev.end, span.end);
        }

        let out = '';
        let last = 0;
        for (const span of merged) {
            out += escapeHtml(raw.slice(last, span.start));
            out += `<mark class="text-highlight">${escapeHtml(raw.slice(span.start, span.end))}</mark>`;
            last = span.end;
        }
        out += escapeHtml(raw.slice(last));
        return out;
    }

    function getVoiceTag(source) {
        if (source === 'designed') {
            return { label: 'DESIGNED', className: 'voice-tag-designed' };
        }
        if (source === 'uploaded') {
            return { label: 'CLONE', className: 'voice-tag-clone' };
        }
        const fallback = (source || 'UNKNOWN').toString().toUpperCase();
        return { label: fallback, className: 'voice-tag-unknown' };
    }

    searchInput.addEventListener('input', () => {
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => {
            currentSearch = searchInput.value.trim();
            currentPage = 1;
            loadVoices();
        }, 300);
    });

    sourceFilter.addEventListener('change', () => {
        currentSource = sourceFilter.value;
        currentPage = 1;
        loadVoices();
    });

    prevBtn.addEventListener('click', () => {
        if (currentPage > 1) {
            currentPage -= 1;
            loadVoices();
        }
    });

    nextBtn.addEventListener('click', () => {
        currentPage += 1;
        loadVoices();
    });

    // Preview button handler
    document.addEventListener('click', (e) => {
        const previewBtn = e.target.closest('.preview-btn');
        if (!previewBtn) return;

        const voiceId = previewBtn.dataset.id;
        const previewUrl = `/api/voices/${voiceId}/preview`;

        if (window.waveformManager) {
            window.waveformManager.play(`waveform-${voiceId}`, previewUrl, previewBtn);
        } else {
            console.error('WaveformManager not loaded');
        }
    });

    // Delete button handler
    document.addEventListener('click', async (e) => {
        const deleteBtn = e.target.closest('.delete-btn');
        if (!deleteBtn) return;

        const voiceId = deleteBtn.dataset.id;
        const voiceName = deleteBtn.dataset.name;

        if (!confirm(`Delete voice "${voiceName}"? This cannot be undone.`)) {
            return;
        }

        deleteBtn.disabled = true;
        deleteBtn.textContent = 'Deleting...';

        try {
            const response = await fetch(`/api/voices/${voiceId}`, { method: 'DELETE' });
            if (!response.ok) {
                const data = await response.json();
                throw new Error(data.detail || 'Failed to delete');
            }

            await loadVoices();

        } catch (error) {
            alert('Failed to delete voice: ' + error.message);
            deleteBtn.disabled = false;
            deleteBtn.textContent = 'Delete';
        }
    });

    loadVoices();
    });
</script>
{% endblock %}
